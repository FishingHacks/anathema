!_TAG_EXTRA_DESCRIPTION	anonymous	/Include tags for non-named objects like lambda/
!_TAG_EXTRA_DESCRIPTION	fileScope	/Include tags of file scope/
!_TAG_EXTRA_DESCRIPTION	pseudo	/Include pseudo tags/
!_TAG_EXTRA_DESCRIPTION	subparser	/Include tags generated by subparsers/
!_TAG_FIELD_DESCRIPTION	epoch	/the last modified time of the input file (only for F\/file kind tag)/
!_TAG_FIELD_DESCRIPTION	file	/File-restricted scoping/
!_TAG_FIELD_DESCRIPTION	input	/input file/
!_TAG_FIELD_DESCRIPTION	name	/tag name/
!_TAG_FIELD_DESCRIPTION	pattern	/pattern/
!_TAG_FIELD_DESCRIPTION	typeref	/Type and name of a variable or typedef/
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_KIND_DESCRIPTION!Rust	C,constant	/A constant/
!_TAG_KIND_DESCRIPTION!Rust	M,macro	/Macro Definition/
!_TAG_KIND_DESCRIPTION!Rust	P,method	/A method/
!_TAG_KIND_DESCRIPTION!Rust	c,implementation	/implementation/
!_TAG_KIND_DESCRIPTION!Rust	e,enumerator	/An enum variant/
!_TAG_KIND_DESCRIPTION!Rust	f,function	/Function/
!_TAG_KIND_DESCRIPTION!Rust	g,enum	/Enum/
!_TAG_KIND_DESCRIPTION!Rust	i,interface	/trait interface/
!_TAG_KIND_DESCRIPTION!Rust	m,field	/A struct field/
!_TAG_KIND_DESCRIPTION!Rust	n,module	/module/
!_TAG_KIND_DESCRIPTION!Rust	s,struct	/structural type/
!_TAG_KIND_DESCRIPTION!Rust	t,typedef	/Type Alias/
!_TAG_KIND_DESCRIPTION!Rust	v,variable	/Global variable/
!_TAG_OUTPUT_EXCMD	mixed	/number, pattern, mixed, or combineV2/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_OUTPUT_VERSION	0.0	/current.age/
!_TAG_PARSER_VERSION!Rust	0.0	/current.age/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROC_CWD	/home/togglebit/projects/rust/anathema/anathema-default-widgets/	//
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	6.1.0	/v6.1.0/
ABSOLUTE	src/position.rs	/^const ABSOLUTE: &str = "absolute";$/;"	C
ALIGNMENT	src/layout/alignment.rs	/^pub const ALIGNMENT: &str = "alignment";$/;"	C
AXIS	src/layout/mod.rs	/^pub static AXIS: &str = "axis";$/;"	v
Absolute	src/position.rs	/^    Absolute,$/;"	e	enum:Placement
Align	src/alignment.rs	/^impl Widget for Align {$/;"	c
Align	src/alignment.rs	/^pub struct Align;$/;"	s
Alignment	src/layout/alignment.rs	/^impl TryFrom<CommonVal<'_>> for Alignment {$/;"	c
Alignment	src/layout/alignment.rs	/^pub enum Alignment {$/;"	g
Axis	src/layout/mod.rs	/^impl TryFrom<CommonVal<'_>> for Axis {$/;"	c
Axis	src/layout/mod.rs	/^pub enum Axis {$/;"	g
BORDER_EDGE_BOTTOM	src/border.rs	/^pub const BORDER_EDGE_BOTTOM: usize = 5;$/;"	C
BORDER_EDGE_BOTTOM_LEFT	src/border.rs	/^pub const BORDER_EDGE_BOTTOM_LEFT: usize = 6;$/;"	C
BORDER_EDGE_BOTTOM_RIGHT	src/border.rs	/^pub const BORDER_EDGE_BOTTOM_RIGHT: usize = 4;$/;"	C
BORDER_EDGE_LEFT	src/border.rs	/^pub const BORDER_EDGE_LEFT: usize = 7;$/;"	C
BORDER_EDGE_RIGHT	src/border.rs	/^pub const BORDER_EDGE_RIGHT: usize = 3;$/;"	C
BORDER_EDGE_TOP	src/border.rs	/^pub const BORDER_EDGE_TOP: usize = 1;$/;"	C
BORDER_EDGE_TOP_LEFT	src/border.rs	/^pub const BORDER_EDGE_TOP_LEFT: usize = 0;$/;"	C
BORDER_EDGE_TOP_RIGHT	src/border.rs	/^pub const BORDER_EDGE_TOP_RIGHT: usize = 2;$/;"	C
BORDER_STYLE	src/border.rs	/^pub const BORDER_STYLE: &str = "border_style";$/;"	C
BOTTOM	src/lib.rs	/^pub(crate) const BOTTOM: &str = "bottom";$/;"	C
Backward	src/layout/mod.rs	/^    Backward,$/;"	e	enum:Direction
Border	src/border.rs	/^impl Border {$/;"	c
Border	src/border.rs	/^impl Widget for Border {$/;"	c
Border	src/border.rs	/^pub struct Border {$/;"	s
BorderLayout	src/layout/border.rs	/^impl BorderLayout {$/;"	c
BorderLayout	src/layout/border.rs	/^pub struct BorderLayout {$/;"	s
BorderPainter	src/border.rs	/^impl BorderPainter {$/;"	c
BorderPainter	src/border.rs	/^struct BorderPainter {$/;"	s
BorderSize	src/border.rs	/^impl BorderSize {$/;"	c
BorderSize	src/border.rs	/^pub(crate) struct BorderSize {$/;"	s
BorderStyle	src/border.rs	/^impl BorderStyle {$/;"	c
BorderStyle	src/border.rs	/^impl Display for BorderStyle {$/;"	c
BorderStyle	src/border.rs	/^impl TryFrom<&EvalValue<'_>> for BorderStyle {$/;"	c
BorderStyle	src/border.rs	/^pub enum BorderStyle {$/;"	g
Bottom	src/layout/alignment.rs	/^    Bottom,$/;"	e	enum:Alignment
Bottom	src/position.rs	/^    Bottom(u32),$/;"	e	enum:VertEdge
BottomLeft	src/layout/alignment.rs	/^    BottomLeft,$/;"	e	enum:Alignment
BottomRight	src/layout/alignment.rs	/^    BottomRight,$/;"	e	enum:Alignment
Brush	src/border.rs	/^impl Brush {$/;"	c
Brush	src/border.rs	/^struct Brush {$/;"	s
Buffer	src/canvas.rs	/^impl Buffer {$/;"	c
Buffer	src/canvas.rs	/^struct Buffer {$/;"	s
CLAMP	src/overflow.rs	/^const CLAMP: &str = "clamp";$/;"	C
Canvas	src/canvas.rs	/^impl Canvas {$/;"	c
Canvas	src/canvas.rs	/^impl Default for Canvas {$/;"	c
Canvas	src/canvas.rs	/^impl Widget for Canvas {$/;"	c
Canvas	src/canvas.rs	/^pub struct Canvas {$/;"	s
Cell	src/canvas.rs	/^enum Cell {$/;"	g
Centre	src/layout/alignment.rs	/^    Centre,$/;"	e	enum:Alignment
Centre	src/text.rs	/^    Centre,$/;"	e	enum:TextAlignment
Column	src/stacks/column.rs	/^impl Default for Column {$/;"	c
Column	src/stacks/column.rs	/^impl Widget for Column {$/;"	c
Column	src/stacks/column.rs	/^pub struct Column(Stack);$/;"	s
Container	src/container.rs	/^impl Widget for Container {$/;"	c
Container	src/container.rs	/^pub struct Container;$/;"	s
Custom	src/border.rs	/^    Custom(String),$/;"	e	enum:BorderStyle
DEFAULT_FACTOR	src/layout/expand.rs	/^const DEFAULT_FACTOR: usize = 1;$/;"	C
DEFAULT_SLIM_EDGES	src/border.rs	/^pub const DEFAULT_SLIM_EDGES: [char; 8] = ['┌', '─', '┐', '│', '┘', '─', '└', '│/;"	C
DEFAULT_THICK_EDGES	src/border.rs	/^pub const DEFAULT_THICK_EDGES: [char; 8] = ['╔', '═', '╗', '║', '╝', '═', '╚', '║/;"	C
DIRECTION	src/layout/mod.rs	/^pub static DIRECTION: &str = "direction";$/;"	v
Direction	src/layout/mod.rs	/^impl TryFrom<CommonVal<'_>> for Direction {$/;"	c
Direction	src/layout/mod.rs	/^pub enum Direction {$/;"	g
Empty	src/canvas.rs	/^    Empty,$/;"	e	enum:Cell
Error	src/border.rs	/^    type Error = ();$/;"	t	implementation:Sides
Error	src/border.rs	/^    type Error = Infallible;$/;"	t	implementation:BorderStyle
Error	src/layout/alignment.rs	/^    type Error = ();$/;"	t	implementation:Alignment
Error	src/layout/mod.rs	/^    type Error = ();$/;"	t	implementation:Axis
Error	src/layout/mod.rs	/^    type Error = ();$/;"	t	implementation:Direction
Error	src/position.rs	/^    type Error = ();$/;"	t	implementation:Placement
Error	src/text.rs	/^    type Error = ();$/;"	t	implementation:TextAlignment
Expand	src/expand.rs	/^impl Widget for Expand {$/;"	c
Expand	src/expand.rs	/^pub struct Expand;$/;"	s
Forward	src/layout/mod.rs	/^    Forward,$/;"	e	enum:Direction
HEIGHT	src/lib.rs	/^pub(crate) const HEIGHT: &str = "height";$/;"	C
HStack	src/stacks/hstack.rs	/^impl Default for HStack {$/;"	c
HStack	src/stacks/hstack.rs	/^impl Widget for HStack {$/;"	c
HStack	src/stacks/hstack.rs	/^pub struct HStack(Stack);$/;"	s
Horizontal	src/layout/mod.rs	/^    Horizontal,$/;"	e	enum:Axis
HorzEdge	src/position.rs	/^pub enum HorzEdge {$/;"	g
LEFT	src/lib.rs	/^pub(crate) const LEFT: &str = "left";$/;"	C
Left	src/layout/alignment.rs	/^    Left,$/;"	e	enum:Alignment
Left	src/position.rs	/^    Left(u32),$/;"	e	enum:HorzEdge
Left	src/text.rs	/^    Left,$/;"	e	enum:TextAlignment
Line	src/border.rs	/^impl Line {$/;"	c
Line	src/border.rs	/^struct Line {$/;"	s
MAX_HEIGHT	src/lib.rs	/^pub(crate) const MAX_HEIGHT: &str = "max_height";$/;"	C
MAX_WIDTH	src/lib.rs	/^pub(crate) const MAX_WIDTH: &str = "max_width";$/;"	C
MIN_HEIGHT	src/lib.rs	/^pub(crate) const MIN_HEIGHT: &str = "min_height";$/;"	C
MIN_WIDTH	src/lib.rs	/^pub(crate) const MIN_WIDTH: &str = "min_width";$/;"	C
Many	src/layout/many.rs	/^impl Many {$/;"	c
Many	src/layout/many.rs	/^pub struct Many {$/;"	s
Occupied	src/canvas.rs	/^    Occupied(char, Style),$/;"	e	enum:Cell
Overflow	src/overflow.rs	/^impl Overflow {$/;"	c
Overflow	src/overflow.rs	/^impl Widget for Overflow {$/;"	c
Overflow	src/overflow.rs	/^pub struct Overflow {$/;"	s
PADDING	src/padding.rs	/^const PADDING: &str = "padding";$/;"	C
PLACEMENT	src/position.rs	/^const PLACEMENT: &str = "placement";$/;"	C
Padding	src/padding.rs	/^impl Widget for Padding {$/;"	c
Padding	src/padding.rs	/^pub struct Padding(PaddingValues);$/;"	s
PaddingValues	src/padding.rs	/^impl PaddingValues {$/;"	c
PaddingValues	src/padding.rs	/^struct PaddingValues {$/;"	s
Placement	src/position.rs	/^impl TryFrom<CommonVal<'_>> for Placement {$/;"	c
Placement	src/position.rs	/^pub enum Placement {$/;"	g
Position	src/position.rs	/^impl Default for Position {$/;"	c
Position	src/position.rs	/^impl Widget for Position {$/;"	c
Position	src/position.rs	/^pub struct Position {$/;"	s
RELATIVE	src/position.rs	/^const RELATIVE: &str = "relative";$/;"	C
RIGHT	src/lib.rs	/^pub(crate) const RIGHT: &str = "right";$/;"	C
Relative	src/position.rs	/^    Relative,$/;"	e	enum:Placement
Right	src/layout/alignment.rs	/^    Right,$/;"	e	enum:Alignment
Right	src/position.rs	/^    Right(u32),$/;"	e	enum:HorzEdge
Right	src/text.rs	/^    Right,$/;"	e	enum:TextAlignment
Row	src/stacks/row.rs	/^impl Default for Row {$/;"	c
Row	src/stacks/row.rs	/^impl Widget for Row {$/;"	c
Row	src/stacks/row.rs	/^pub struct Row(Stack);$/;"	s
Sides	src/border.rs	/^impl Default for Sides {$/;"	c
Sides	src/border.rs	/^impl From<&str> for Sides {$/;"	c
Sides	src/border.rs	/^impl TryFrom<&EvalValue<'_>> for Sides {$/;"	c
SizeMod	src/layout/many.rs	/^impl SizeMod {$/;"	c
SizeMod	src/layout/many.rs	/^pub(crate) struct SizeMod {$/;"	s
Spacer	src/spacer.rs	/^impl Widget for Spacer {$/;"	c
Spacer	src/spacer.rs	/^pub struct Spacer;$/;"	s
Span	src/text.rs	/^impl Widget for Span {$/;"	c
Span	src/text.rs	/^pub struct Span;$/;"	s
Stack	src/stacks/mod.rs	/^impl Stack {$/;"	c
Stack	src/stacks/mod.rs	/^pub struct Stack(Axis);$/;"	s
TEXT_ALIGN	src/text.rs	/^pub(crate) const TEXT_ALIGN: &str = "text_align";$/;"	C
TOP	src/lib.rs	/^pub(crate) const TOP: &str = "top";$/;"	C
TestInstance	src/testing.rs	/^impl TestInstance<'_> {$/;"	c
TestInstance	src/testing.rs	/^pub struct TestInstance<'bp> {$/;"	s
TestRunner	src/testing.rs	/^impl TestRunner {$/;"	c
TestRunner	src/testing.rs	/^pub struct TestRunner {$/;"	s
TestState	src/testing.rs	/^impl TestState {$/;"	c
TestState	src/testing.rs	/^pub struct TestState {$/;"	s
Text	src/text.rs	/^impl Widget for Text {$/;"	c
Text	src/text.rs	/^pub struct Text {$/;"	s
TextAlignment	src/text.rs	/^impl TryFrom<CommonVal<'_>> for TextAlignment {$/;"	c
TextAlignment	src/text.rs	/^pub enum TextAlignment {$/;"	g
Thick	src/border.rs	/^    Thick,$/;"	e	enum:BorderStyle
Thin	src/border.rs	/^    Thin,$/;"	e	enum:BorderStyle
Top	src/layout/alignment.rs	/^    Top,$/;"	e	enum:Alignment
Top	src/position.rs	/^    Top(u32),$/;"	e	enum:VertEdge
TopLeft	src/layout/alignment.rs	/^    TopLeft,$/;"	e	enum:Alignment
TopRight	src/layout/alignment.rs	/^    TopRight,$/;"	e	enum:Alignment
UNCONSTRAINED	src/overflow.rs	/^const UNCONSTRAINED: &str = "unconstrained";$/;"	C
VStack	src/stacks/vstack.rs	/^impl Default for VStack {$/;"	c
VStack	src/stacks/vstack.rs	/^impl Widget for VStack {$/;"	c
VStack	src/stacks/vstack.rs	/^pub struct VStack(Stack);$/;"	s
VertEdge	src/position.rs	/^pub enum VertEdge {$/;"	g
Vertical	src/layout/mod.rs	/^    Vertical,$/;"	e	enum:Axis
WIDTH	src/lib.rs	/^pub(crate) const WIDTH: &str = "width";$/;"	C
WRAP	src/text.rs	/^pub(crate) const WRAP: &str = "wrap";$/;"	C
ZERO	src/layout/many.rs	/^    const ZERO: Self = Self::new(Size::ZERO, Axis::Vertical);$/;"	C	implementation:SizeMod
ZStack	src/stacks/zstack.rs	/^impl Widget for ZStack {$/;"	c
ZStack	src/stacks/zstack.rs	/^pub struct ZStack;$/;"	s
alignment	src/layout/mod.rs	/^pub(crate) mod alignment;$/;"	n
alignment	src/lib.rs	/^mod alignment;$/;"	n
apply	src/layout/many.rs	/^    fn apply(&mut self, size: Size) {$/;"	P	implementation:SizeMod
as_size	src/border.rs	/^    pub(crate) fn as_size(&self) -> Size {$/;"	P	implementation:BorderSize
attribute_storage	src/testing.rs	/^    attribute_storage: AttributeStorage<'bp>,$/;"	m	struct:TestInstance
axis	src/border.rs	/^    axis: Axis,$/;"	m	struct:Line
axis	src/layout/many.rs	/^    axis: Axis,$/;"	m	struct:SizeMod
axis	src/layout/many.rs	/^    pub axis: Axis,$/;"	m	struct:Many
backend	src/testing.rs	/^    backend: &'bp mut TestBackend,$/;"	m	struct:TestInstance
backend	src/testing.rs	/^    backend: TestBackend,$/;"	m	struct:TestRunner
basic_column	src/stacks/column.rs	/^    fn basic_column() {$/;"	f	module:test
basic_row	src/stacks/row.rs	/^    fn basic_row() {$/;"	f	module:test
blueprint	src/testing.rs	/^    blueprint: Blueprint,$/;"	m	struct:TestRunner
border	src/layout/mod.rs	/^pub(crate) mod border;$/;"	n
border	src/lib.rs	/^mod border;$/;"	n
border_bottom_right	src/border.rs	/^    fn border_bottom_right() {$/;"	f	module:test
border_left	src/border.rs	/^    fn border_left() {$/;"	f	module:test
border_right	src/border.rs	/^    fn border_right() {$/;"	f	module:test
border_size	src/border.rs	/^    fn border_size(&self, sides: Sides) -> BorderSize {$/;"	P	implementation:Border
border_size	src/layout/border.rs	/^    pub border_size: BorderSize,$/;"	m	struct:BorderLayout
border_style	src/border.rs	/^    pub border_style: BorderStyle,$/;"	m	struct:Border
border_top	src/border.rs	/^    fn border_top() {$/;"	f	module:test
border_top_bottom	src/border.rs	/^    fn border_top_bottom() {$/;"	f	module:test
border_top_left	src/border.rs	/^    fn border_top_left() {$/;"	f	module:test
bottom	src/alignment.rs	/^    fn bottom() {$/;"	f	module:test
bottom	src/border.rs	/^    bottom: Line,$/;"	m	struct:BorderPainter
bottom	src/border.rs	/^    pub bottom: u8,$/;"	m	struct:BorderSize
bottom	src/padding.rs	/^    bottom: u16,$/;"	m	struct:PaddingValues
bottom_left	src/alignment.rs	/^    fn bottom_left() {$/;"	f	module:test
bottom_left	src/border.rs	/^    pub bottom_left: u8,$/;"	m	struct:BorderSize
bottom_right	src/alignment.rs	/^    fn bottom_right() {$/;"	f	module:test
bottom_right	src/border.rs	/^    pub bottom_right: u8,$/;"	m	struct:BorderSize
bottom_up_vstack	src/stacks/vstack.rs	/^    fn bottom_up_vstack() {$/;"	f	module:test
break_word_wrap	src/text.rs	/^    fn break_word_wrap() {$/;"	f	module:test
buffer	src/canvas.rs	/^    buffer: Buffer,$/;"	m	struct:Canvas
canvas	src/lib.rs	/^mod canvas;$/;"	n
centre	src/alignment.rs	/^    fn centre() {$/;"	f	module:test
centre_alignment	src/text.rs	/^    fn centre_alignment() {$/;"	f	module:test
char_wrap_layout_multiple_spans	src/text.rs	/^    fn char_wrap_layout_multiple_spans() {$/;"	f	module:test
clamp	src/overflow.rs	/^    fn clamp(&mut self, children: Size, parent: Size) {$/;"	P	implementation:Overflow
clamp_prevents_scrolling	src/overflow.rs	/^    fn clamp_prevents_scrolling() {$/;"	f	module:test
column	src/stacks/mod.rs	/^mod column;$/;"	n
component_registry	src/testing.rs	/^    component_registry: ComponentRegistry,$/;"	m	struct:TestRunner
container	src/container.rs	/^    fn container() {$/;"	f	module:test
container	src/lib.rs	/^mod container;$/;"	n
copy_from	src/canvas.rs	/^    fn copy_from(other: &mut Buffer, size: Size) -> Self {$/;"	P	implementation:Buffer
custom_border	src/border.rs	/^    fn custom_border() {$/;"	f	module:test
default	src/border.rs	/^    fn default() -> Self {$/;"	P	implementation:Sides
default	src/canvas.rs	/^    fn default() -> Self {$/;"	P	implementation:Canvas
default	src/position.rs	/^    fn default() -> Self {$/;"	P	implementation:Position
default	src/stacks/column.rs	/^    fn default() -> Self {$/;"	P	implementation:Column
default	src/stacks/hstack.rs	/^    fn default() -> Self {$/;"	P	implementation:HStack
default	src/stacks/row.rs	/^    fn default() -> Self {$/;"	P	implementation:Row
default	src/stacks/vstack.rs	/^    fn default() -> Self {$/;"	P	implementation:VStack
direction	src/layout/many.rs	/^    pub direction: Direction,$/;"	m	struct:Many
direction	src/overflow.rs	/^    direction: Direction,$/;"	m	struct:Overflow
distribute_size	src/layout/expand.rs	/^fn distribute_size(weights: &[usize], mut total: usize) -> Vec<usize> {$/;"	f
drain	src/canvas.rs	/^    fn drain(&mut self) -> impl Iterator<Item = (LocalPos, char, Style)> + '_ {$/;"	P	implementation:Buffer
draw	src/border.rs	/^    fn draw<F>(&self, f: &mut F)$/;"	P	implementation:Line
edges	src/border.rs	/^    pub edges: [char; 8],$/;"	m	struct:Border
edges	src/border.rs	/^    pub fn edges(&self) -> [char; 8] {$/;"	P	implementation:BorderStyle
end	src/border.rs	/^    end: u16,$/;"	m	struct:Line
end_cap	src/border.rs	/^    end_cap: Option<Brush>,$/;"	m	struct:Line
erase	src/canvas.rs	/^    pub fn erase(&mut self, pos: impl Into<LocalPos>) {$/;"	P	implementation:Canvas
expand	src/expand.rs	/^    fn expand() {}$/;"	f	module:test
expand	src/layout/mod.rs	/^pub(crate) mod expand;$/;"	n
expand	src/lib.rs	/^mod expand;$/;"	n
factory	src/testing.rs	/^    factory: Factory,$/;"	m	struct:TestRunner
fixed_height	src/stacks/vstack.rs	/^    fn fixed_height() {$/;"	f	module:test
fixed_size	src/border.rs	/^    fn fixed_size() {$/;"	f	module:test
fixed_width	src/stacks/vstack.rs	/^    fn fixed_width() {$/;"	f	module:test
floating_widgets	src/testing.rs	/^    floating_widgets: FloatingWidgets,$/;"	m	struct:TestInstance
floats	src/position.rs	/^    fn floats(&self) -> bool {$/;"	P	implementation:Position
fmt	src/border.rs	/^    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {$/;"	P	implementation:BorderStyle
fn	src/layout/many.rs	/^    const fn new(max_size: Size, axis: Axis) -> Self {$/;"	C	implementation:SizeMod
from	src/border.rs	/^    fn from(value: &str) -> Self {$/;"	P	implementation:Sides
get	src/canvas.rs	/^    fn get(&self, pos: impl Into<LocalPos>) -> Option<&Cell> {$/;"	P	implementation:Buffer
get	src/canvas.rs	/^    pub fn get(&mut self, pos: impl Into<LocalPos>) -> Option<(char, Style)> {$/;"	P	implementation:Canvas
get_mut	src/canvas.rs	/^    fn get_mut(&mut self, pos: impl Into<LocalPos>) -> Option<&mut Cell> {$/;"	P	implementation:Buffer
get_mut	src/canvas.rs	/^    pub fn get_mut(&mut self, pos: impl Into<LocalPos>) -> Option<(&mut char, &mut Style)> {$/;"	P	implementation:Canvas
get_set_glyph	src/canvas.rs	/^    fn get_set_glyph() {$/;"	f	module:test
globals	src/testing.rs	/^    globals: Globals,$/;"	m	struct:TestRunner
glyph	src/border.rs	/^    glyph: char,$/;"	m	struct:Brush
height	src/layout/border.rs	/^    pub height: Option<usize>,$/;"	m	struct:BorderLayout
horz_edge	src/position.rs	/^    horz_edge: HorzEdge,$/;"	m	struct:Position
hstack	src/stacks/mod.rs	/^mod hstack;$/;"	n
inner	src/layout/many.rs	/^    inner: Size,$/;"	m	struct:SizeMod
inner_bounds	src/border.rs	/^    fn inner_bounds(&self, mut pos: Pos, mut size: Size) -> Rect {$/;"	P	implementation:Border
inner_bounds	src/padding.rs	/^    fn inner_bounds(&self, mut pos: Pos, mut size: Size) -> Rect {$/;"	P	implementation:Padding
inner_size	src/layout/many.rs	/^    pub fn inner_size(&self) -> Size {$/;"	P	implementation:SizeMod
inner_size	src/overflow.rs	/^    inner_size: Size,$/;"	m	struct:Overflow
instance	src/testing.rs	/^    pub fn instance(&mut self) -> TestInstance<'_> {$/;"	P	implementation:TestRunner
iter	src/canvas.rs	/^    fn iter(&self) -> impl Iterator<Item = (LocalPos, char, &Style)> + '_ {$/;"	P	implementation:Buffer
layout	src/alignment.rs	/^    fn layout<'bp>($/;"	P	implementation:Align
layout	src/border.rs	/^    fn layout<'bp>($/;"	P	implementation:Border
layout	src/canvas.rs	/^    fn layout<'bp>($/;"	P	implementation:Canvas
layout	src/container.rs	/^    fn layout<'bp>($/;"	P	implementation:Container
layout	src/expand.rs	/^    fn layout<'bp>($/;"	P	implementation:Expand
layout	src/layout/border.rs	/^    pub(crate) fn layout<'bp>($/;"	P	implementation:BorderLayout
layout	src/layout/many.rs	/^    pub(crate) fn layout<'bp>($/;"	P	implementation:Many
layout	src/lib.rs	/^mod layout;$/;"	n
layout	src/overflow.rs	/^    fn layout<'bp>($/;"	P	implementation:Overflow
layout	src/padding.rs	/^    fn layout<'bp>($/;"	P	implementation:Padding
layout	src/position.rs	/^    fn layout<'bp>($/;"	P	implementation:Position
layout	src/spacer.rs	/^    fn layout<'bp>($/;"	P	implementation:Spacer
layout	src/stacks/column.rs	/^    fn layout<'bp>($/;"	P	implementation:Column
layout	src/stacks/hstack.rs	/^    fn layout<'bp>($/;"	P	implementation:HStack
layout	src/stacks/mod.rs	/^    fn layout<'bp>($/;"	P	implementation:Stack
layout	src/stacks/row.rs	/^    fn layout<'bp>($/;"	P	implementation:Row
layout	src/stacks/vstack.rs	/^    fn layout<'bp>($/;"	P	implementation:VStack
layout	src/stacks/zstack.rs	/^    fn layout<'bp>($/;"	P	implementation:ZStack
layout	src/text.rs	/^    fn layout<'bp>($/;"	P	implementation:Span
layout	src/text.rs	/^    fn layout<'bp>($/;"	P	implementation:Text
layout_all_expansions	src/layout/expand.rs	/^pub fn layout_all_expansions<'bp>($/;"	f
layout_all_spacers	src/layout/spacers.rs	/^pub fn layout_all_spacers<'bp>($/;"	f
left	src/alignment.rs	/^    fn left() {$/;"	f	module:test
left	src/border.rs	/^    left: Line,$/;"	m	struct:BorderPainter
left	src/border.rs	/^    pub left: u8,$/;"	m	struct:BorderSize
left	src/padding.rs	/^    left: u16,$/;"	m	struct:PaddingValues
line_break	src/text.rs	/^    fn line_break() {$/;"	f	module:test
make	src/border.rs	/^pub(crate) fn make(attributes: &Attributes<'_>) -> Box<dyn AnyWidget> {$/;"	f
many	src/layout/mod.rs	/^pub(crate) mod many;$/;"	n
max_height	src/layout/border.rs	/^    pub max_height: Option<usize>,$/;"	m	struct:BorderLayout
max_size	src/layout/many.rs	/^    max_size: Size,$/;"	m	struct:SizeMod
max_width	src/layout/border.rs	/^    pub max_width: Option<usize>,$/;"	m	struct:BorderLayout
middle	src/border.rs	/^    middle: Option<Brush>,$/;"	m	struct:Line
min_height	src/layout/border.rs	/^    pub min_height: Option<usize>,$/;"	m	struct:BorderLayout
min_width	src/layout/border.rs	/^    pub min_width: Option<usize>,$/;"	m	struct:BorderLayout
multi_line_with_span	src/text.rs	/^    fn multi_line_with_span() {$/;"	f	module:test
new	src/border.rs	/^    fn new(glyphs: &[char; 8], border_size: BorderSize, size: Size) -> Self {$/;"	P	implementation:BorderPainter
new	src/border.rs	/^    pub fn new(glyph: char, width: u8) -> Self {$/;"	P	implementation:Brush
new	src/canvas.rs	/^    pub fn new(size: Size) -> Self {$/;"	P	implementation:Buffer
new	src/layout/many.rs	/^    const fn new(max_size: Size, axis: Axis) -> Self {$/;"	P	implementation:SizeMod
new	src/layout/many.rs	/^    pub fn new(direction: Direction, axis: Axis, unconstrained: bool) -> Self {$/;"	P	implementation:Many
new	src/testing.rs	/^    pub fn new() -> Self {$/;"	P	implementation:TestState
new	src/testing.rs	/^    pub fn new(src: &str, size: impl Into<Size>) -> Self {$/;"	P	implementation:TestRunner
no_space_left	src/layout/many.rs	/^    fn no_space_left(&self) -> bool {$/;"	P	implementation:SizeMod
offset	src/overflow.rs	/^    offset: Pos,$/;"	m	struct:Overflow
offset	src/overflow.rs	/^    pub fn offset(&self) -> Pos {$/;"	P	implementation:Overflow
offset	src/testing.rs	/^    pub offset: Value<i32>,$/;"	m	struct:TestState
overflow	src/lib.rs	/^mod overflow;$/;"	n
overflow	src/overflow.rs	/^    fn overflow() {$/;"	f	module:test
padding	src/lib.rs	/^mod padding;$/;"	n
padding_all	src/padding.rs	/^    fn padding_all() {$/;"	f	module:test
padding_bottom	src/padding.rs	/^    fn padding_bottom() {$/;"	f	module:test
padding_bottom_inclusive	src/padding.rs	/^    fn padding_bottom_inclusive() {$/;"	f	module:test
padding_left	src/padding.rs	/^    fn padding_left() {$/;"	f	module:test
padding_left_inclusive	src/padding.rs	/^    fn padding_left_inclusive() {$/;"	f	module:test
padding_right	src/padding.rs	/^    fn padding_right() {$/;"	f	module:test
padding_right_inclusive	src/padding.rs	/^    fn padding_right_inclusive() {$/;"	f	module:test
padding_top	src/padding.rs	/^    fn padding_top() {$/;"	f	module:test
padding_top_inclusive	src/padding.rs	/^    fn padding_top_inclusive() {$/;"	f	module:test
paint	src/border.rs	/^    fn paint<'bp>($/;"	P	implementation:Border
paint	src/border.rs	/^    fn paint<F>(&mut self, f: &mut F)$/;"	P	implementation:BorderPainter
paint	src/canvas.rs	/^    fn paint<'bp>($/;"	P	implementation:Canvas
paint	src/expand.rs	/^    fn paint<'bp>($/;"	P	implementation:Expand
paint	src/overflow.rs	/^    fn paint<'bp>($/;"	P	implementation:Overflow
paint	src/padding.rs	/^    fn paint<'bp>($/;"	P	implementation:Padding
paint	src/position.rs	/^    fn paint<'bp>($/;"	P	implementation:Position
paint	src/spacer.rs	/^    fn paint<'bp>($/;"	P	implementation:Spacer
paint	src/text.rs	/^    fn paint<'bp>($/;"	P	implementation:Text
placement	src/position.rs	/^    placement: Placement,$/;"	m	struct:Position
pop	src/layout/expand.rs	/^    fn pop(n: &mut usize) -> bool {$/;"	f	function:distribute_size
pos	src/canvas.rs	/^    pos: Pos,$/;"	m	struct:Canvas
position	src/alignment.rs	/^    fn position<'bp>($/;"	P	implementation:Align
position	src/border.rs	/^    fn position<'bp>($/;"	P	implementation:Border
position	src/canvas.rs	/^    fn position<'bp>($/;"	P	implementation:Canvas
position	src/container.rs	/^    fn position<'bp>($/;"	P	implementation:Container
position	src/expand.rs	/^    fn position<'bp>($/;"	P	implementation:Expand
position	src/lib.rs	/^mod position;$/;"	n
position	src/overflow.rs	/^    fn position<'bp>($/;"	P	implementation:Overflow
position	src/padding.rs	/^    fn position<'bp>($/;"	P	implementation:Padding
position	src/position.rs	/^    fn position<'bp>($/;"	P	implementation:Position
position	src/spacer.rs	/^    fn position<'bp>($/;"	P	implementation:Spacer
position	src/stacks/column.rs	/^    fn position<'bp>($/;"	P	implementation:Column
position	src/stacks/hstack.rs	/^    fn position<'bp>($/;"	P	implementation:HStack
position	src/stacks/mod.rs	/^    fn position<'bp>($/;"	P	implementation:Stack
position	src/stacks/row.rs	/^    fn position<'bp>($/;"	P	implementation:Row
position	src/stacks/vstack.rs	/^    fn position<'bp>($/;"	P	implementation:VStack
position	src/stacks/zstack.rs	/^    fn position<'bp>($/;"	P	implementation:ZStack
position	src/text.rs	/^    fn position<'bp>($/;"	P	implementation:Span
position	src/text.rs	/^    fn position<'bp>($/;"	P	implementation:Text
position_bottom	src/position.rs	/^    fn position_bottom() {$/;"	f	module:test
position_bottom_left	src/position.rs	/^    fn position_bottom_left() {$/;"	f	module:test
position_bottom_right	src/position.rs	/^    fn position_bottom_right() {$/;"	f	module:test
position_right	src/position.rs	/^    fn position_right() {$/;"	f	module:test
position_top	src/position.rs	/^    fn position_top() {$/;"	f	module:test
position_top_left	src/position.rs	/^    fn position_top_left() {$/;"	f	module:test
position_top_right	src/position.rs	/^    fn position_top_right() {$/;"	f	module:test
positions	src/canvas.rs	/^    positions: Box<[Cell]>,$/;"	m	struct:Buffer
put	src/canvas.rs	/^    fn put(&mut self, c: char, style: Style, pos: impl Into<LocalPos>) {$/;"	P	implementation:Buffer
put	src/canvas.rs	/^    pub fn put(&mut self, c: char, style: Style, pos: impl Into<LocalPos>) {$/;"	P	implementation:Canvas
register_default_widgets	src/lib.rs	/^pub fn register_default_widgets(factory: &mut Factory) {$/;"	f
remove	src/canvas.rs	/^    fn remove(&mut self, pos: impl Into<LocalPos>) {$/;"	P	implementation:Buffer
remove_glyph	src/canvas.rs	/^    fn remove_glyph() {$/;"	f	module:test
render_assert	src/testing.rs	/^    pub fn render_assert(&mut self, expected: &str) -> &mut Self {$/;"	P	implementation:TestInstance
resize_canvas	src/canvas.rs	/^    fn resize_canvas() {$/;"	f	module:test
right	src/alignment.rs	/^    fn right() {$/;"	f	module:test
right	src/border.rs	/^    pub right: u8,$/;"	m	struct:BorderSize
right	src/border.rs	/^    right: Line,$/;"	m	struct:BorderPainter
right	src/padding.rs	/^    right: u16,$/;"	m	struct:PaddingValues
right_alignment	src/text.rs	/^    fn right_alignment() {$/;"	f	module:test
row	src/stacks/mod.rs	/^mod row;$/;"	n
scroll	src/overflow.rs	/^    pub fn scroll(&mut self, direction: Direction, amount: Pos) {$/;"	P	implementation:Overflow
scroll_down	src/overflow.rs	/^    pub fn scroll_down(&mut self) {$/;"	P	implementation:Overflow
scroll_down_by	src/overflow.rs	/^    pub fn scroll_down_by(&mut self, amount: i32) {$/;"	P	implementation:Overflow
scroll_left	src/overflow.rs	/^    pub fn scroll_left(&mut self) {$/;"	P	implementation:Overflow
scroll_left_by	src/overflow.rs	/^    pub fn scroll_left_by(&mut self, amount: i32) {$/;"	P	implementation:Overflow
scroll_right	src/overflow.rs	/^    pub fn scroll_right(&mut self) {$/;"	P	implementation:Overflow
scroll_right_by	src/overflow.rs	/^    pub fn scroll_right_by(&mut self, amount: i32) {$/;"	P	implementation:Overflow
scroll_to	src/overflow.rs	/^    pub fn scroll_to(&mut self, pos: Pos) {$/;"	P	implementation:Overflow
scroll_up	src/overflow.rs	/^    pub fn scroll_up(&mut self) {$/;"	P	implementation:Overflow
scroll_up_by	src/overflow.rs	/^    pub fn scroll_up_by(&mut self, amount: i32) {$/;"	P	implementation:Overflow
sides	src/border.rs	/^    pub sides: Sides,$/;"	m	struct:Border
single_layout	src/layout/mod.rs	/^pub(crate) fn single_layout<'bp>($/;"	f
size	src/canvas.rs	/^    size: Size,$/;"	m	struct:Buffer
size	src/padding.rs	/^    fn size(&self) -> Size {$/;"	P	implementation:PaddingValues
sized_by_child	src/border.rs	/^    fn sized_by_child() {$/;"	f	module:test
spacer	src/lib.rs	/^mod spacer;$/;"	n
spacers	src/layout/mod.rs	/^mod spacers;$/;"	n
stacks	src/lib.rs	/^mod stacks;$/;"	n
start	src/border.rs	/^    start: LocalPos,$/;"	m	struct:Line
start_cap	src/border.rs	/^    start_cap: Option<Brush>,$/;"	m	struct:Line
states	src/testing.rs	/^    states: &'bp mut States,$/;"	m	struct:TestInstance
states	src/testing.rs	/^    states: States,$/;"	m	struct:TestRunner
test	src/alignment.rs	/^mod test {$/;"	n
test	src/border.rs	/^mod test {$/;"	n
test	src/canvas.rs	/^mod test {$/;"	n
test	src/container.rs	/^mod test {$/;"	n
test	src/expand.rs	/^mod test {$/;"	n
test	src/overflow.rs	/^mod test {$/;"	n
test	src/padding.rs	/^mod test {$/;"	n
test	src/position.rs	/^mod test {$/;"	n
test	src/stacks/column.rs	/^mod test {$/;"	n
test	src/stacks/row.rs	/^mod test {$/;"	n
test	src/stacks/vstack.rs	/^mod test {$/;"	n
test	src/stacks/zstack.rs	/^mod test {$/;"	n
test	src/text.rs	/^mod test {$/;"	n
testing	src/lib.rs	/^mod testing;$/;"	n
text	src/lib.rs	/^mod text;$/;"	n
text	src/testing.rs	/^    text: StringStorage,$/;"	m	struct:TestInstance
text_key	src/text.rs	/^    text_key: LayoutKey,$/;"	m	struct:Text
thick_border	src/border.rs	/^    fn thick_border() {$/;"	f	module:test
thin_border	src/border.rs	/^    fn thin_border() {$/;"	f	module:test
to_constraints	src/layout/many.rs	/^    fn to_constraints(&self) -> Constraints {$/;"	P	implementation:SizeMod
top	src/alignment.rs	/^    fn top() {$/;"	f	module:test
top	src/border.rs	/^    pub top: u8,$/;"	m	struct:BorderSize
top	src/border.rs	/^    top: Line,$/;"	m	struct:BorderPainter
top	src/padding.rs	/^    top: u16,$/;"	m	struct:PaddingValues
top_left	src/alignment.rs	/^    fn top_left() {$/;"	f	module:test
top_left	src/border.rs	/^    pub top_left: u8,$/;"	m	struct:BorderSize
top_right	src/alignment.rs	/^    fn top_right() {$/;"	f	module:test
top_right	src/border.rs	/^    pub top_right: u8,$/;"	m	struct:BorderSize
translate	src/canvas.rs	/^    pub fn translate(&self, pos: Pos) -> LocalPos {$/;"	P	implementation:Canvas
tree	src/testing.rs	/^    tree: WidgetTree<'bp>,$/;"	m	struct:TestInstance
try_from	src/border.rs	/^    fn try_from(value: &EvalValue<'_>) -> Result<Self, Self::Error> {$/;"	P	implementation:BorderStyle
try_from	src/border.rs	/^    fn try_from(value: &EvalValue<'_>) -> Result<Self, Self::Error> {$/;"	P	implementation:Sides
try_from	src/layout/alignment.rs	/^    fn try_from(value: CommonVal<'_>) -> Result<Self, Self::Error> {$/;"	P	implementation:Alignment
try_from	src/layout/mod.rs	/^    fn try_from(value: CommonVal<'_>) -> Result<Self, Self::Error> {$/;"	P	implementation:Axis
try_from	src/layout/mod.rs	/^    fn try_from(value: CommonVal<'_>) -> Result<Self, Self::Error> {$/;"	P	implementation:Direction
try_from	src/position.rs	/^    fn try_from(value: CommonVal<'_>) -> Result<Self, Self::Error> {$/;"	P	implementation:Placement
try_from	src/text.rs	/^    fn try_from(value: CommonVal<'_>) -> Result<Self, Self::Error> {$/;"	P	implementation:TextAlignment
unconstrained	src/layout/many.rs	/^    unconstrained: bool,$/;"	m	struct:Many
unsized_empty_border	src/border.rs	/^    fn unsized_empty_border() {$/;"	f	module:test
used_size	src/layout/many.rs	/^    pub(crate) used_size: SizeMod,$/;"	m	struct:Many
value	src/testing.rs	/^    pub value: Value<usize>,$/;"	m	struct:TestState
vert_edge	src/position.rs	/^    vert_edge: VertEdge,$/;"	m	struct:Position
viewport	src/testing.rs	/^    viewport: Viewport,$/;"	m	struct:TestInstance
vstack	src/stacks/mod.rs	/^mod vstack;$/;"	n
vstack	src/stacks/vstack.rs	/^    fn vstack() {$/;"	f	module:test
vstack_overflow	src/stacks/vstack.rs	/^    fn vstack_overflow() {$/;"	f	module:test
width	src/border.rs	/^    width: u8,$/;"	m	struct:Brush
width	src/layout/border.rs	/^    pub width: Option<usize>,$/;"	m	struct:BorderLayout
will_draw	src/border.rs	/^    fn will_draw(&self) -> bool {$/;"	P	implementation:Line
with_state	src/testing.rs	/^    pub fn with_state<F>(&mut self, mut f: F) -> &mut Self$/;"	P	implementation:TestInstance
with_widget	src/testing.rs	/^    pub(crate) fn with_widget<F>(&mut self, mut f: F) -> &mut Self$/;"	P	implementation:TestInstance
word_wrap	src/text.rs	/^    fn word_wrap() {$/;"	f	module:test
word_wrap_excessive_space	src/text.rs	/^    fn word_wrap_excessive_space() {$/;"	f	module:test
zstack	src/stacks/mod.rs	/^mod zstack;$/;"	n
zstack	src/stacks/zstack.rs	/^    fn zstack() {$/;"	f	module:test
